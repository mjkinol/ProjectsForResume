Mark Kinol
CS104 - HW5


Problem 5:
A size 12 array that would cause this quicksort algorithm to achieve the worst 
runtime would be: 34 30 26 22 18 14 12 16 20 24 28 32

This would cause the worst possible case for quicksort, because after the first 
iteration we want exactly one to be placed to the right of the pivot. With this 
array, this hould hold true. To do this we need medianof3 to always be the 
second largest value in the set. This will cause only one value greater 
than the value at medianof3 to be swapped down the list. Swapping a value for each 
iteration of the for loop. This way only one value is being sorted per for loop and 
the value being sorted will used the most possible swaps. This can be more clearly 
described with a 4 element array example. Say you have the array 12, 8, 6, 10. 10 will 
be the median and it will stay in place. Then next 11 will have swap with each element 
all the way thru the list, which is the worst case. This will then repeat for the 
next two elements, but it will have to perform one less swap each time, however, it 
will still be the worst case for the algorithm. The array above just shows a big 
example of this where the medianof3 is the second largest value in the set, causing 
only one new element to be place to the right of the pivot each time. This achieves 
the worst case for the algorithm

4c: The running time of this new k-way templated mergeSort is (k)nlogn. This is becuase each merge will 
run in k(n) time. We know this becuase the outer for loop were the merging actually takes place on line 95 
will run n times, while the innder for loop will run k times. As as a result, the runtime of these two 
loops will cause the merge function to run in k(n) time. Addtionally, the mergeSort function will run in 
logn time. This is becuase mergeSort must have a k of at least 2, which is the worst case for the merge 
function, as it will have to recurs more than any higher value for k (this is true except for the special 
case of k=n). In this worst case mergeSort will have to divide the list into halves repreatedly, which 
means that the function will run in logn time. As a result, the whole k-way merge sort will run in (k)
nlogn time. Addtionally, since we were allowed to used the selection sort to sort arrays <= k, if k = n 
this algorithim will look like a selection sort algorithm. Therefore, if k = n the runtime would be n^2.




